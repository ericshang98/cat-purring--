<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>猫咪呼噜声生成器</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 24px;
        }

        .control-panel {
            margin: 20px 0;
        }

        .param-group {
            margin: 15px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            display: flex;
            align-items: center;
        }

        .param-group label {
            width: 180px;
            color: #444;
            font-size: 14px;
        }

        .param-group input[type="range"] {
            flex: 1;
            margin: 0 15px;
        }

        .param-group .value {
            width: 50px;
            text-align: right;
            color: #666;
            font-size: 14px;
        }

        .controls {
            text-align: center;
            margin-top: 30px;
        }

        button {
            padding: 12px 25px;
            margin: 0 10px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            outline: none;
        }

        #togglePurr {
            background-color: #4CAF50;
            color: white;
        }

        #togglePurr:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        #resetParams {
            background-color: #ff5252;
            color: white;
        }

        #resetParams:hover {
            background-color: #ff1744;
            transform: translateY(-2px);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #45a049;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
            background: #45a049;
        }

        .range-label {
            font-size: 12px;
            color: #666;
            margin-left: 8px;
        }
        
        .param-group label {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>猫咪呼噜声生成器</h1>
        
        <div class="control-panel">
            <div class="param-group">
                <label>呼噜平衡 <span class="range-label">(-100% Purr In → 0 → +100% Purr Out)</span></label>
                <input type="range" id="purrBalance" min="-1" max="1" step="0.01" value="0">
                <span class="value">0%</span>
            </div>
            
            <div class="param-group">
                <label>呼噜频率 <span class="range-label">(20 PPM → 60 PPM → 100 PPM)</span></label>
                <input type="range" id="purrRate" min="0" max="1" step="0.01" value="0.5">
                <span class="value">60 PPM</span>
            </div>
            
            <div class="param-group">
                <label>整体音量 <span class="range-label">(50% → 100% → 200%)</span></label>
                <input type="range" id="masterVolume" min="0.5" max="2.0" step="0.01" value="1.0">
                <span class="value">100%</span>
            </div>
            
            <div class="param-group">
                <label>音调变化 <span class="range-label">(-100% Relaxed → 0 → +100% Overjoyed)</span></label>
                <input type="range" id="toneControl" min="-1" max="1" step="0.01" value="0">
                <span class="value">0%</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="togglePurr">开始/停止呼噜</button>
            <button id="resetParams">重置参数</button>
        </div>
    </div>

    <script>
        class SampleBasedPurrSynthesizer {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // 创建主音量控制节点
                this.masterVolumeNode = this.audioContext.createGain();
                this.masterVolumeNode.gain.value = 1.0;
                
                // 创建低频滤波器
                this.lowFilter = this.audioContext.createBiquadFilter();
                this.lowFilter.type = 'lowshelf';
                this.lowFilter.frequency.value = 100; // 分界频率100Hz
                this.lowFilter.gain.value = 0;        // 默认无增益
                
                // 创建高频滤波器
                this.highFilter = this.audioContext.createBiquadFilter();
                this.highFilter.type = 'highshelf';
                this.highFilter.frequency.value = 100; // 分界频率100Hz
                this.highFilter.gain.value = 0;        // 默认无增益
                
                // 更新音频处理链
                this.mainGainNode = this.audioContext.createGain();
                this.mainGainNode.connect(this.lowFilter);
                this.lowFilter.connect(this.highFilter);
                this.highFilter.connect(this.masterVolumeNode);
                this.masterVolumeNode.connect(this.audioContext.destination);
                
                // 创建动态压缩器以控制音量峰值
                this.compressor = this.audioContext.createDynamicsCompressor();
                this.compressor.threshold.value = -20; // 当信号超过-20dB时开始压缩
                this.compressor.knee.value = 10;       // 柔和的压缩过渡
                this.compressor.ratio.value = 4;       // 4:1的压缩比
                this.compressor.attack.value = 0.005;  // 5ms的启动时间
                this.compressor.release.value = 0.1;   // 100ms的释放时间
                this.compressor.connect(this.mainGainNode);
                
                // 创建音量包络控制器
                this.envelopeNode = this.audioContext.createGain();
                this.envelopeNode.connect(this.compressor);
                
                this.inhaleBuffer = null;
                this.exhaleBuffer = null;
                this.isPlaying = false;
                this.currentSource = null;
                this.pendingParams = null;
                this.transitionScheduled = false;
                
                // 添加状态管理
                this.currentParams = null;
                this.isTransitioning = false;
                this.scheduledTransition = null;
                
                // 添加滑块状态管理
                this.sliderStates = {
                    purrRate: {
                        value: 0.5,
                        isMoving: false,
                        timeoutId: null
                    },
                    purrBalance: {
                        value: 0,
                        isMoving: false,
                        timeoutId: null
                    },
                    masterVolume: {
                        value: 1.0,
                        isMoving: false,
                        timeoutId: null
                    },
                    toneControl: {
                        value: 0,
                        isMoving: false,
                        timeoutId: null
                    }
                };
                
                // 添加参数更新状态管理
                this.pendingUpdate = null;
            }
            
            async loadSamples() {
                try {
                    const [inhaleResponse, exhaleResponse] = await Promise.all([
                        fetch('audio/purr_in.mp3'),
                        fetch('audio/purr_out.mp3')
                    ]);
                    
                    const [inhaleArrayBuffer, exhaleArrayBuffer] = await Promise.all([
                        inhaleResponse.arrayBuffer(),
                        exhaleResponse.arrayBuffer()
                    ]);
                    
                    this.inhaleBuffer = await this.audioContext.decodeAudioData(inhaleArrayBuffer);
                    this.exhaleBuffer = await this.audioContext.decodeAudioData(exhaleArrayBuffer);
                    
                    return true;
                } catch (error) {
                    console.error('加载音频样本失败:', error);
                    return false;
                }
            }
            
            // 从音频中提取中间部分
            extractCenterPortion(buffer, ratio) {
                const originalLength = buffer.length;
                const extractLength = Math.floor(originalLength / ratio);
                const startOffset = Math.floor((originalLength - extractLength) / 2);
                
                const extractedBuffer = new Float32Array(extractLength);
                const sourceData = buffer.getChannelData(0);
                
                for (let i = 0; i < extractLength; i++) {
                    extractedBuffer[i] = sourceData[startOffset + i];
                }
                
                return extractedBuffer;
            }
            
            createBalancedBreathBuffer(params) {
                // 1. 计算频率比例
                const frequencyRatio = 1.0 + (params.purrRate * 4.0);
                
                // 2. 计算吸气和呼气的音量
                let inhaleVolume, exhaleVolume;
                
                if (params.purrBalance <= 0) {
                    // 滑块在左侧或中点
                    // 左侧(-1): 吸气100%, 呼气50%
                    // 中点(0): 吸气100%, 呼气100%
                    inhaleVolume = 1.0;  // 吸气保持100%
                    exhaleVolume = 0.5 + (Math.abs(params.purrBalance + 1) * 0.5); // 从50%线性增加到100%
                } else {
                    // 滑块在右侧
                    // 右侧(1): 吸气50%, 呼气100%
                    // 中点(0): 吸气100%, 呼气100%
                    exhaleVolume = 1.0;  // 呼气保持100%
                    inhaleVolume = 1.0 - (params.purrBalance * 0.5); // 从100%线性减少到50%
                }
                
                // 3. 提取并调整音量
                const inhaleData = this.extractCenterPortion(this.inhaleBuffer, frequencyRatio)
                    .map(sample => sample * inhaleVolume);
                const exhaleData = this.extractCenterPortion(this.exhaleBuffer, frequencyRatio)
                    .map(sample => sample * exhaleVolume);
                
                // 4. 创建组合缓冲区
                const totalLength = inhaleData.length + exhaleData.length;
                const combinedBuffer = this.audioContext.createBuffer(1, totalLength, this.audioContext.sampleRate);
                const outputData = combinedBuffer.getChannelData(0);
                
                // 5. 复制音频数据
                for (let i = 0; i < inhaleData.length; i++) {
                    outputData[i] = inhaleData[i];
                }
                for (let i = 0; i < exhaleData.length; i++) {
                    outputData[i + inhaleData.length] = exhaleData[i];
                }
                
                // 6. 在切换点处进行音量处理
                const processTransitionPoint = (point) => {
                    const samplesPerMs = this.audioContext.sampleRate / 1000;
                    const silenceLength = Math.floor(samplesPerMs * 5);  // 5ms静音区
                    const fadeLength = Math.floor(samplesPerMs * 5);     // 5ms渐变区
                    
                    // 计算渐变区域的起始和结束位置
                    const fadeStartBefore = point - silenceLength - fadeLength; // -10ms位置
                    const silenceStart = point - silenceLength;                // -5ms位置
                    const silenceEnd = point + silenceLength;                  // +5ms位置
                    const fadeEndAfter = point + silenceLength + fadeLength;   // +10ms位置
                    
                    // 前段渐变：从-10ms到-5ms线性降至0
                    for (let i = 0; i < fadeLength; i++) {
                        const pos = (fadeStartBefore + i + totalLength) % totalLength;
                        const ratio = 1 - (i / fadeLength); // 从1线性降至0
                        outputData[pos] *= ratio;
                    }
                    
                    // 静音区域：从-5ms到+5ms保持为0
                    for (let i = -silenceLength; i <= silenceLength; i++) {
                        const pos = (point + i + totalLength) % totalLength;
                        outputData[pos] = 0;
                    }
                    
                    // 后段渐变：从+5ms到+10ms线性增至1
                    for (let i = 0; i < fadeLength; i++) {
                        const pos = (silenceEnd + i + totalLength) % totalLength;
                        const ratio = i / fadeLength; // 从0线性增至1
                        outputData[pos] *= ratio;
                    }
                };
                
                // 7. 处理所有切换点
                processTransitionPoint(0);                    // 循环起点
                processTransitionPoint(inhaleData.length);    // 吸气到呼气的连接点
                processTransitionPoint(totalLength - 1);      // 循环结束点
                
                return combinedBuffer;
            }
            
            start(params) {
                if (!this.inhaleBuffer || !this.exhaleBuffer) return;
                
                try {
                    this.isPlaying = true;
                    this.currentParams = {...params};
                    
                    // 创建初始音频
                    const buffer = this.createBalancedBreathBuffer(this.currentParams);
                    const source = this.audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.loop = true;
                    
                    // 连接并开始播放
                    source.connect(this.mainGainNode);
                    source.start();
                    
                    this.currentSource = source;
                    this.currentSource.startTime = this.audioContext.currentTime;
                } catch (error) {
                    console.error('开始播放失败:', error);
                    this.isPlaying = false;
                }
            }
            
            stop() {
                this.isPlaying = false;
                if (this.currentSource) {
                    this.currentSource.stop();
                    this.currentSource = null;
                }
            }
            
            updateParams(newParams) {
                this.currentParams = {...newParams};
                this.regenerateAudio();
            }
            
            // 检查参数是否发生实质性变化
            paramsChanged(newParams, currentParams) {
                return Object.keys(newParams).some(key => 
                    Math.abs(newParams[key] - currentParams[key]) > 0.001
                );
            }
            
            scheduleTransition() {
                if (!this.currentSource || !this.pendingParams || this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                try {
                    const currentTime = this.audioContext.currentTime;
                    const bufferDuration = this.currentSource.buffer.duration;
                    const currentOffset = (currentTime - this.currentSource.startTime) % bufferDuration;
                    const timeToNextCycle = bufferDuration - currentOffset;
                    
                    // 创建新的音频源
                    const newBuffer = this.createBalancedBreathBuffer(this.pendingParams);
                    const newSource = this.audioContext.createBufferSource();
                    newSource.buffer = newBuffer;
                    newSource.loop = true;
                    
                    // 安全地连接和启动新音源
                    newSource.connect(this.mainGainNode);
                    newSource.start(currentTime + timeToNextCycle);
                    
                    // 安全地停止旧音源
                    const oldSource = this.currentSource;
                    oldSource.stop(currentTime + timeToNextCycle);
                    
                    // 使用 Promise 确保状态更新的可靠性
                    this.scheduledTransition = setTimeout(() => {
                        this.currentSource = newSource;
                        this.currentSource.startTime = currentTime + timeToNextCycle;
                        this.currentParams = {...this.pendingParams};
                        this.pendingParams = null;
                        this.isTransitioning = false;
                        this.scheduledTransition = null;
                    }, timeToNextCycle * 1000);
                    
                } catch (error) {
                    console.error('Transition failed:', error);
                    this.reset();
                }
            }
            
            scheduleNextCycle(params) {
                // 创建新的音频缓冲区
                const balancedBuffer = this.createBalancedBreathBuffer(params);
                
                // 如果是第一次启动（没有当前音源）
                if (!this.currentSource) {
                    this.currentSource = this.audioContext.createBufferSource();
                    this.currentSource.buffer = balancedBuffer;
                    this.currentSource.loop = true;
                    this.currentSource.startTime = this.audioContext.currentTime;
                    this.currentSource.connect(this.mainGainNode);
                    this.currentSource.start();
                    return;
                }
                
                // 如果是参数更新，则执行平滑过渡
                const currentTime = this.audioContext.currentTime;
                const bufferDuration = this.currentSource.buffer.duration;
                const currentOffset = (currentTime - this.currentSource.startTime) % bufferDuration;
                const timeToNextCycle = bufferDuration - currentOffset;
                
                // 在当前循环结束时更新参数
                setTimeout(() => {
                    if (this.pendingParams) {
                        const oldSource = this.currentSource;
                        
                        // 创建新的音源
                        const newBuffer = this.createBalancedBreathBuffer(this.pendingParams);
                        this.currentSource = this.audioContext.createBufferSource();
                        this.currentSource.buffer = newBuffer;
                        this.currentSource.loop = true;
                        this.currentSource.startTime = currentTime + timeToNextCycle;
                        
                        // 连接并启动新音源
                        this.currentSource.connect(this.mainGainNode);
                        this.currentSource.start(this.currentSource.startTime);
                        
                        // 停止旧音源
                        oldSource.stop(this.currentSource.startTime);
                        
                        this.pendingParams = null;
                        this.transitionScheduled = false;
                    }
                }, (timeToNextCycle - 0.1) * 1000);
            }
            
            // 添加音量包络控制方法
            applyVolumeEnvelope(time) {
                const attackTime = 0.05;  // 50ms
                const releaseTime = 0.1;  // 100ms
                
                this.envelopeNode.gain.cancelScheduledValues(time);
                this.envelopeNode.gain.setValueAtTime(0, time);
                this.envelopeNode.gain.linearRampToValueAtTime(1, time + attackTime);
                this.envelopeNode.gain.linearRampToValueAtTime(0.8, time + attackTime + releaseTime);
            }
            
            // 添加音量控制方法
            setMasterVolume(volume) {
                if (this.masterVolumeNode) {
                    // 使用 exponentialRampToValueAtTime 实现平滑的音量变化
                    const currentTime = this.audioContext.currentTime;
                    this.masterVolumeNode.gain.cancelScheduledValues(currentTime);
                    this.masterVolumeNode.gain.setValueAtTime(this.masterVolumeNode.gain.value, currentTime);
                    this.masterVolumeNode.gain.exponentialRampToValueAtTime(volume, currentTime + 0.1);
                }
            }
            
            // 添加音调控制方法
            setToneCharacter(value) {
                // value范围: -1 (relaxed) 到 1 (overjoyed)
                // 转换dB: 
                // +10% ≈ +0.8dB
                // -10% ≈ -0.9dB
                // +20% ≈ +1.6dB
                // -20% ≈ -1.9dB
                
                if (value < 0) {
                    // Relaxed模式: 
                    // 低频增加10% (+0.8dB)
                    // 高频减少20% (-1.9dB)
                    const ratio = Math.abs(value);
                    const lowGainChange = 0.8 * ratio;  // 最大+0.8dB
                    const highGainChange = -1.9 * ratio; // 最大-1.9dB
                    
                    this.lowFilter.gain.setTargetAtTime(lowGainChange, this.audioContext.currentTime, 0.1);
                    this.highFilter.gain.setTargetAtTime(highGainChange, this.audioContext.currentTime, 0.1);
                } else if (value > 0) {
                    // Overjoyed模式:
                    // 低频减少20% (-1.9dB)
                    // 高频增加10% (+0.8dB)
                    const ratio = value;
                    const lowGainChange = -1.9 * ratio;  // 最大-1.9dB
                    const highGainChange = 0.8 * ratio;  // 最大+0.8dB
                    
                    this.lowFilter.gain.setTargetAtTime(lowGainChange, this.audioContext.currentTime, 0.1);
                    this.highFilter.gain.setTargetAtTime(highGainChange, this.audioContext.currentTime, 0.1);
                } else {
                    // 中间值：无变化
                    this.lowFilter.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
                    this.highFilter.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
                }
            }
            
            // 重置所有参数和状态
            reset() {
                // 停止所有正在进行的转换
                if (this.scheduledTransition) {
                    clearTimeout(this.scheduledTransition);
                    this.scheduledTransition = null;
                }
                
                // 重置所有音频节点
                this.isTransitioning = false;
                this.pendingParams = null;
                
                // 重置音频处理器状态
                this.lowFilter.gain.cancelScheduledValues(this.audioContext.currentTime);
                this.highFilter.gain.cancelScheduledValues(this.audioContext.currentTime);
                this.masterVolumeNode.gain.cancelScheduledValues(this.audioContext.currentTime);
                
                // 设置默认值
                this.lowFilter.gain.setValueAtTime(0, this.audioContext.currentTime);
                this.highFilter.gain.setValueAtTime(0, this.audioContext.currentTime);
                this.masterVolumeNode.gain.setValueAtTime(1, this.audioContext.currentTime);
                
                // 如果正在播放，使用新参数重新开始
                if (this.isPlaying) {
                    this.stop();
                    const defaultParams = {
                        purrBalance: 0,
                        purrRate: 0,
                        masterVolume: 1,
                        toneControl: 0
                    };
                    this.start(defaultParams);
                }
            }
            
            // 修改滑块处理逻辑
            handleSliderInput(id, value) {
                // 更新待处理的参数
                const newParams = {
                    ...this.currentParams,
                    [id]: value
                };
                
                // 存储待处理的更新
                this.pendingUpdate = newParams;
                
                // 如果没有正在进行的转换，则安排下一次转换
                if (!this.isTransitioning) {
                    this.scheduleNextTransition();
                }
            }

            // 新增：重新生成音频的方法
            regenerateAudio() {
                if (!this.isPlaying) return;

                try {
                    // 停止当前播放
                    if (this.currentSource) {
                        this.currentSource.stop();
                    }

                    // 使用当前参数创建新的音频缓冲区
                    const newBuffer = this.createBalancedBreathBuffer(this.currentParams);
                    
                    // 创建新的音源
                    const newSource = this.audioContext.createBufferSource();
                    newSource.buffer = newBuffer;
                    newSource.loop = true;
                    
                    // 连接音频处理链
                    newSource.connect(this.mainGainNode);
                    
                    // 立即开始播放
                    newSource.start();
                    this.currentSource = newSource;
                    this.currentSource.startTime = this.audioContext.currentTime;

                } catch (error) {
                    console.error('重新生成音频失败:', error);
                }
            }

            // 应用滑块最终值
            applySliderValue(id, value) {
                switch(id) {
                    case 'purrRate':
                        // 计算频率比例 (1.0 到 5.0)
                        const ratio = 1.0 + (value * 4.0); // 线性映射
                        this.updatePurrRate(ratio);
                        break;
                        
                    case 'purrBalance':
                        this.updatePurrBalance(value);
                        break;
                        
                    case 'masterVolume':
                        this.setMasterVolume(value);
                        break;
                        
                    case 'toneControl':
                        this.setToneCharacter(value);
                        break;
                }
            }

            // 获取当前滑块状态
            getSliderState(id) {
                return this.sliderStates[id] || null;
            }

            // 修改转换调度逻辑
            scheduleNextTransition() {
                if (!this.isPlaying || !this.currentSource || !this.pendingUpdate) return;
                
                this.isTransitioning = true;
                
                // 计算到下一个循环点的时间
                const currentTime = this.audioContext.currentTime;
                const bufferDuration = this.currentSource.buffer.duration;
                const currentOffset = (currentTime - this.currentSource.startTime) % bufferDuration;
                const timeToNextCycle = bufferDuration - currentOffset;
                
                // 在下一个循环点进行切换
                setTimeout(() => {
                    if (this.pendingUpdate) {
                        try {
                            // 使用最新的待处理参数创建新的音频
                            const newBuffer = this.createBalancedBreathBuffer(this.pendingUpdate);
                            const newSource = this.audioContext.createBufferSource();
                            newSource.buffer = newBuffer;
                            newSource.loop = true;
                            
                            // 连接音频处理链
                            newSource.connect(this.mainGainNode);
                            
                            // 在当前源结束时开始播放新源
                            const switchTime = currentTime + timeToNextCycle;
                            newSource.start(switchTime);
                            this.currentSource.stop(switchTime);
                            
                            // 更新状态
                            this.currentSource = newSource;
                            this.currentSource.startTime = switchTime;
                            this.currentParams = {...this.pendingUpdate};
                            this.pendingUpdate = null;
                        } catch (error) {
                            console.error('音频转换失败:', error);
                        }
                    }
                    
                    this.isTransitioning = false;
                    
                    // 如果在转换过程中有新的更新，则安排下一次转换
                    if (this.pendingUpdate) {
                        this.scheduleNextTransition();
                    }
                }, timeToNextCycle * 1000);
            }
        }

        // 主程序
        document.addEventListener('DOMContentLoaded', async () => {
            const synthesizer = new SampleBasedPurrSynthesizer();
            let isPurring = false;
            
            // 加载音频样本
            const loaded = await synthesizer.loadSamples();
            if (!loaded) {
                alert('加载音频样本失败！');
                return;
            }
            
            // 获取所有参数输入
            const params = {};
            const inputs = document.querySelectorAll('input[type="range"]');
            inputs.forEach(input => {
                params[input.id] = parseFloat(input.value);
                
                // 实时更新显示
                input.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    e.target.nextElementSibling.textContent = formatValue(input.id, value);
                    synthesizer.handleSliderInput(input.id, value);
                });

                // 滑块释放时的处理
                input.addEventListener('change', (e) => {
                    const value = parseFloat(e.target.value);
                    synthesizer.applySliderValue(input.id, value);
                });
                
                // 初始化显示
                input.nextElementSibling.textContent = formatValue(input.id, parseFloat(input.value));
            });
            
            // 开始/停止按钮
            document.getElementById('togglePurr').addEventListener('click', () => {
                isPurring = !isPurring;
                if (isPurring) {
                    synthesizer.start(params);
                } else {
                    synthesizer.stop();
                }
            });
            
            // 重置按钮
            document.getElementById('resetParams').addEventListener('click', () => {
                // 首先重置合成器状态
                synthesizer.reset();
                
                // 然后重置UI
                inputs.forEach(input => {
                    input.value = input.defaultValue;
                    params[input.id] = parseFloat(input.defaultValue);
                    input.nextElementSibling.textContent = formatValue(input.id, input.defaultValue);
                });
            });
            
            // 添加音量控制监听器
            const volumeSlider = document.getElementById('masterVolume');
            volumeSlider.addEventListener('input', (e) => {
                const volume = parseFloat(e.target.value);
                e.target.nextElementSibling.textContent = formatValue('masterVolume', volume);
                synthesizer.setMasterVolume(volume);
            });
            
            // 添加音调控制监听器
            const toneSlider = document.getElementById('toneControl');
            toneSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                e.target.nextElementSibling.textContent = formatValue('toneControl', value);
                synthesizer.setToneCharacter(value);
            });
        });

        // 修改值显示的格式化函数
        function formatValue(id, value) {
            switch(id) {
                case 'purrRate': {
                    // 直接计算实际PPM
                    const ratio = 1.0 + (value * 4.0);
                    const ppm = Math.round(20 * ratio);
                    return `${ppm} PPM`;
                }
                case 'purrBalance':
                case 'toneControl':
                    return `${Math.round(value * 100)}%`;
                case 'masterVolume':
                    return `${Math.round(value * 100)}%`;
                default:
                    return value.toFixed(2);
            }
        }
    </script>
</body>
</html> 